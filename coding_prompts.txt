add a window named AnalysisWindow. The root layout is vertical line layout. it has 2 horizon layout weight 3 and 7. On up area, there's a multiple text edit and a reserved area. space ratio is 70% 30%. The down area has 2 multiple column tables parallel in vertical in average. tables wrapped by group widget named: Positive, Negitive. 


write a load_tags function to load public.csv to DataFrame df_public and private.csv to df_pvivate. and join them by field "tag" to a df_tags. Note that one or both of them may not exist. df_tags should not be null. df_tags should at leat has following fileds: tag, stance, path, value, lable,translate_cn,comments,weight,statistics. if the field data is nan or null. should set as empty string.

if df_tags has no one of following fileds: tag, stance, path, value, lable,translate_cn,comments,weight,statistics. Add the filed


move layout code to init_ui, keep member init code in __init__


write a function named parse_tags, accept a prompt_text as str. Split it by '\n' and strip each line, remove empty lines. For the line 0 and 1, if there's a ':' before any ',', remove the sub string before ':' and ':' it self. split line 0 and 1 by ',' and strip each sub string. line 0 is positive_tags, line 1 is negitive_tags. line 0 not exists, positive_tags should be empty list, same to negitive_tags. The rest lines should be joined by '\n' as extra_data. If no more lines extra_data should be empty string. return positive_tags, negitive_tags, extra_data



call parse_tags with the input of self.text_edit. receive the inputs as positive_tags, negitive_tags, extra_data. Update positive_tags to positive_table and negitive_tags to negative_table


add columns to self.positive_table and self.negative_table: tag, stance, path, value, lable,translate_cn,comments,weight,statistics, action

declare a COLUMNS as ordered dict with all strings: Tag: tag, Group: path, Value: value, Bookmark: lable, Name: translate_cn, Comments: comments


a function for dataframe to QTableWidget, with 4 parameters: QTableWidget, dataframe, field_mapping as ordered dict, extra_fields as string list. Clear the table, and rebuild the columns by field_mapping keys + extra_fields. Fill dataframe data into the table and leaving the extra_fields columns empty.


add a tree control between self.positive_table and self.negative_table with weight 1


set both table multiple selection, not editable, dragable.


write a draggable tree to accept drag data from table. override the dropEvent.


write code to handle tables item been dragged to the tree.


add a member function named on_button_edit, with 2 parameters: QTableWidget, edit_row as int. Get data from the table and update to self.tag_database, follow the mapping of COL2FIELD, which index to table column and the value on index as the field of dataframe. The first column value is the unique major key to the dataframe. If the key does not exists, add a new row to dataframe.


positive_tags, negative_tags are list of string. create 2 dataframe for each and put the list data into a row named 'tag'


join positive_df with tag_database by 'tag' row. keep all tag_database columns. if the tag not in tag_database, the columns are empty string. the same to negative_df.





add a dataframe row edit dialog. 
it accepts 4 parameters in its __init__: a dataframe, a field_name_mapping as dict, a unique_field as str, unique_field_value as any.
it has a editable table that has 2 columns: Field, Value and 2 buttons named OK and Cancel. 
use the unique_field and unique_field_value to filter row. if row is empty. create a new dataframe with the same column. set its unique_field as unique_field_value, other fields data are empty string . create a ordered dict from the row data. show this dict to table, which first column shows the key name that mapping from field_name_mapping. the second column shows the dict value.
when user click OK. read data from table and update to dataframe row by unique_field and unique_field_value. if data not exits, append a new row to dataframe.


create a new_df dataframe with the same columns of df. add a new row and set unique_field value as unique_field_value. other fileds are empty string.


database is a dataframe , check if unique_field has unique_field_value in database

get 'path' field data from self.tag_database unique and update them to self.tree as QTreeWidget. the slash in path show the tree hierarchy.


write a function named save_tag_data. acceapt a dataframe. Split the dataframe to 2 : if private field == 'Y', to df_private, else to df_public. save df_private to private.csv and save df_public to public.csv


receive the data from table here, it might be multiple rows. get each row's first data.


write a table widget. override mimeData to set the mine data as the selected rows first column data.


in dropEvent(), get the tree node it droped on. caclulate the full path from root to current node. slash as the seperator



update dataframe self.database set the field 'path' as full_path where field 'tag' in list selected_data.


